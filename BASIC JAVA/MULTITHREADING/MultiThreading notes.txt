
https://www.interviewbit.com/multithreading-interview-questions/

==thread
==multithreading
==ways to create a thread  
==life cycle of a thread

===sleep join
 wait notify
 deadlock 
 ==thread scheduler  - Thread Priority , Time slicing

demon thread

==garbage collection


 multithreading in Java?
---------------------------------------------------------------
-> Multithreading in Java is a process that allows multiple threads to run concurrently, enabling the execution of multiple tasks simultaneously.

 -> This improves the performance of applications, especially on multi-core systems. 


Thread
-------------
->Threads are lightweight processes which can be execute concurrently.

-> concurrent execution of multiple threads can be good regarding performance and CPU utilization 

-> since we can work on more than one task at once through different threads running in parallel



Can you explain the Java thread lifecycle?
------------------------------------------------------------------------------


New:
 -> When a thread is created but no yet started, It  is in the  New state.

Runnable:
-> After calling the start method on a thread object, it enters the Runnable state.
-> A runnable thread is eligible to be scheduled for execution by the operating system.

Running:
-> When  a thread from the runnable state gets scheduled by the operating system, It enters the Running state

Blocked/Waited:
-> A thread can enter the blocked or waiting state under various circumstances.

For Example:
-> Thread A  wants to enter synchronized code but it is unable to as Thread B thread is operating in that synchronized block on the same object.
 The  thread A  has to wait until the  thread B  exits the synchronized block.
 A thread in the blocked state is unable to perform any execution and thus never consume any cycle of the Central Processing Unit (CPU).
 Hence, we can say that thread A remains idle until the thread scheduler reactivates thread A, which is in the waiting or blocked state.

->Thread can also a waiting state  due to explicit calls to methods like wait, join, sleep


Terminated:
-> A thread completes its execution and enters the terminated state. This happens when the run() method of the thread finishes executing.


can we start a thread twice
-----------------------------------------------------------------------------------------------------------------------
-> No, once a thread has completed its execution  and entered the Terminated state. It cannot be restarted.
-> if you try to start a thread that has already been terminated , it will thrown an Illegal Thread State Exception.



Java Threads | How to create a thread in Java
-------------------------------------------------------------------------------------------------------------------------------------

There are two ways to create a thread:
-> By extending Thread class
-> By implementing Runnable interface.

Thread class:
-> Thread class provide constructors and methods to create and perform operations on a thread. Thread class extends Object class and implements Runnable interface.

Runnable interface:
-> The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run().
1.	public void run(): is used to perform action for a thread.

Starting a thread:
-> The start() method of Thread class is used to start a newly created thread. It performs the following tasks:
o	A new thread starts(with new callstack).
o	The thread moves from New state to the Runnable state.
o	When the thread gets a chance to execute, its target run() method will run.







Thread Scheduler in Java
-----------------------------------------------------------------------------------------------------------------------
-> A component of Java that decides which thread to run or execute and which thread to wait is called a thread scheduler in Java. 

-> In Java, a thread is only chosen by a thread scheduler if it is in the runnable state.

->  However, if there is more than one thread in the runnable state, it is up to the thread scheduler to pick one of the threads and ignore the other ones. 

->There are some criteria that decide which thread will execute first. There are two factors for scheduling a thread i.e. Priority and Time of arrival.

Priority: 
-> Priority of each thread lies between 1 to 10. If a thread has a higher priority, it means that thread has got a better chance of getting picked up by the thread scheduler.

Time of Arrival: 
-> Suppose two threads of the same priority enter the runnable state, then priority cannot be the factor to pick a thread from these two threads.
 In such a case, arrival time of thread is considered by the thread scheduler. A thread that arrived first gets the preference over the other threads.




sleep
-------------------

-> There are two Overloaded methods of sleep() method present in Thread class.

->  First one accepts only an one argument, whereas the another one  accepts two arguments. 

-> The Sleep() method is used to stop the execution of the current thread for a specific duration of the time and 
after that time duration gets over, the thread starts its execution from where it has left.

-> When we call the sleep() method, It throws a checked Exception , We can handle the Exception either by using throws keyword or by using try and catch block.



->run-> printing  for loop 1 to 4 numbers, inside sleep for 1 sec , then after printing numbers.


join
---------------

-> Join method in java allows one thread to wait until another thread completes its execution.
-> In simpler words, it means it waits for the other thread to die.


->run-> printing  for loop 1 to 4 numbers, inside sleep for 1 sec , then after printing numbers.
   
 -> create 3 threads 
    t1. start
   t1.join
    t2.start
    t3.start

  -> t1 first complete its task 1234 and then t2 ,t3 will execute 



 -> When the main thread invokes the join() method then, it is said that the main thread is in the waiting state. 

 -> The main thread then waits for the child threads to complete their tasks. 

 -> When the child threads complete their job, a notification is sent to the main thread, which again moves the thread from waiting to the active state.


Daemon Thread
---------------------------
->Daemon thread in Java is a service provider thread that provides services to the user thread. 

 -> Daemon Thread is a low priority thread that runs in the background to perform tasks such as garbage collection.

-> 
 when all the user threads finish their execution, the JVM automatically terminates the daemon thread.



Java Garbage Collection
-------------------------------
Garbage Collection is process of reclaiming the runtime unused memory automatically. In other words, it is a way to destroy the unused objects.

finalize() method
-----------------------
-> The finalize() method is invoked each time before the object is garbage collected. This method can be used to perform cleanup processing.

-> The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, 
you can use finalize method to perform cleanup processing (destroying remaining objects). 








 synchronization 
--------------------------------------------------------------

-> Synchronization in Java is the capability to control the access of multiple threads to any shared resource.
->  Java Synchronization is better option where we want to allow only one thread to access the shared resource.


-> Synchronization in Java is a mechanism that ensures that multiple threads can access shared resources in a controlled manner to prevent data inconsistency and thread interference.

 -> It is achieved using the synchronized keyword,
    which can be applied to methods or blocks of code. This is crucial in concurrent programming to avoid race conditions and ensure thread safety.


 What is the purpose of the volatile keyword in Java?
----------------------------------------------------------
-> The volatile keyword in Java is used to indicate that a variable's value will be modified by different threads. 
-> It ensures that the value of the volatile variable is always read from the main memory and not from the thread's local cache.
->  This guarantees visibility of changes to the variable across threads, preventing issues related to memory consistency.



Java Thread Pool
----------------------
Java Thread pool represents a group of worker threads that are waiting for the job and reused many times.

In the case of a thread pool, a group of fixed-size threads is created.
 A thread from the thread pool is pulled out and assigned a job by the service provider. 
After completion of the job, the thread is contained in the thread pool again.









